---
title: Schema 与数据类型优化
date: 2023-06-22 14:09:00 +0800
author: 
categories: [Database]
tags: [MySQL, Database]
pin: false
math: false
mermaid: false
img_path: /assets/images/
---

ch4 Schema 与数据类型优化

## 选择优化的数据类型

整型类型，实数类型，字符串类型，日期和时间类型，位数据类型，选择标识符（identifier），特殊类型数据

### 一般选择正确的数据类型简单原则:

**A** 更小的通常更好

尽量使用可以正确存储数据的最小数据类型，更小的数据类型意味着占用更小的磁盘、内存和 CPU 缓存，并且处理时需要的 CPU 周期也更小。

**B** 简单就好

简单数据类型需要更小的 CPU 周期。例如，整型比字符操作代价更低。

**C** 尽量避免 NULL

最好指定列为 NOT NULL，除非真的需要存储 NULL 值。

在为列选择数据类型时，第一步需要确定合适的大类型：数字、字符串、时间等；下一步是选择具体类型。

### 整数类型

有两种类型的数字：整数（whole number）和实数（real number）

整数：TINYINT 8位，SMALLINT 16位，MEDIUMINT 24位，INT 32位，BIGINT 64位

### 实数类型

实数是带有小数部分的数字。也可以使用 DECIMAL 存储比 BIGINT 还大的整数。

DECIMAL 类型用于存储精确的小数。浮点和 DECIMAL 类型都可以指定精度。对于 DECIMAL 列，可以指定小数点前后所允许的最大位数。如 DECIMAL(18, 9) 。

浮点类型在存储同样范围的值时，通常比 DECIMAL 使用更少的空间。FLOAT 使用 4 个字节存储。DOUBLE 占用 8 个字节。

尽量只在对小数进行精确计算时才使用 DECIMAL —— 例如存储财务数据。

### 字符串类型

* VARCHAR & CHAR

VARCHAR 用于存储可变长字符串，是最常见的字符串数据类型。比定长类型更节省空间，因为它仅使用必要的空间，字符串越短使用越少的空间

CHAR 类型是定长的；MySQL 总是根据定义的字符串长度分配足够的空间。存储 CHAR 值时，MySQL 会删除所有的末尾空格。CHAR 适合存储很短的字符串，或者所有值都接近同一个长度。例如，CHAR 非常适合存储 MD5 值（定长的）。

与 VARCHAR 和 CHAR 类似的还有 BINARY 和 VARBINARY，它们存储的是二进制字符串。二进制字符串存储的是字节码而不是字符。

* BLOB & TEXT

BLOB 和 TEXT 都是为存储很大的数据而设计的字符串数据类型，分别采用二进制和字符方式存储。

字符串类型 TINYTEXT SMALLTEXT TEXT MEDIUMTEXT LONGTEXT

二进制类型 TINYBLOB SMALLBLOB BLOB MEDIUMBLOB LONGBLOB

与其他类型不同，MySQL会把 BLOB 和 TEXT 值当作一个独立的对象处理。存储引擎在存储时通常会做特殊处理。当 BLOB 和 TEXT 值太大时，InnoDB 会使用专门的外部存储区域来进行存储，每个值在行内需要1-4个字节存储一个指针，然后在外部存储区域存储实际的值。

BLOB 和 TEXT 家族之间仅有的不同是 BLOB 类型存储的是二进制数据，没有排序规则或字符集，而 TEXT 类型有字符集和排序规则。

MySQL 不能将 BLOB 和 TEXT 列全部长度的字符串进行索引，也不能使用这些索引消除排序。

使用枚举（ENUM）代替字符串类型

枚举列可以把一些不重复的字符串存储成一个预定义的集合。

### 日期和时间类型

* DATETIME

1001 年到 9999 年，精度为秒。它把日期和时间封装到格式为 YYYYMMDDHHMMSS 的整数中，与时区无关。使用 8 个字节的存储空间。

* TIMESTAMP

保存了从 1970 年 1 月 1 日午夜（格林尼治标准时间）以来的秒数，它和 UNIX 时间戳相同。TIMESTAMP 只使用 4 个字节的存储空间。 `UNIX_TIMESTAMP()` 函数把日期转换为 Unix 时间戳

- ### 位数据类型

BIT

SET

在整数列上进行按位操作

- ### 选择标识符（identifier）

一般用标识列与其他值进行比较，或者通过标识列寻找其他列，标识列也可能在另外的表中作为外键使用。

1. 整数类型

   标识列最好的选择是整数，因为它们很快并且可以使用 AUTO_INCREMENT

2. ENUM 和 SET 类型

   对于某些只包含固定状态或者类型的静态“定义表”来说可能没有问题。ENUM 和 SET 列适合存储固定信息，例如有序的状态，产品类型，人的性别

3. 字符串类型

   如果可能，尽量避免使用字符串类型作为标识列。

- ### 特殊类型数据

某些类型的数据并不直接与内置类型一致。

## MySQL schema 设计中的陷阱

有些普遍的好或坏的设计原则，本小节讨论设计 MySQL 的 schema 的问题。

- 太多的列

  MySQL 的存储引擎 API 在工作时需要在服务器层和存储引擎层之间通过行缓冲格式拷贝数据，然后在服务器层将缓冲内容解码成各个列。从行缓冲中将解码过的列转换成行数据结构的待解时非常高的。**转换的代价依赖于列的数量。**

- 太多的关联

  所谓的“实体-属性-值”（EAV）设计模式是一个常见的糟糕的设计模式。

  一个粗略的经验法则：如果希望查询执行得快速且并发性好，单个查询最好在 12 个表以内做关联。

- 全能的枚举

  注意防止过度使用枚举（ENUM）

  例如

  ```sql
  CREATE TABLE ... (
  	country enum('', '0', '1', '2', ... , '31')
  )
  ```

- 变相的枚举

  枚举（ENUM）列允许在列中存储一组定义值中的单个值，集合（SET）列则允许在列中存储一组定义值中的一个或多个值。有时候这可能比较容易导致混乱。

- 非此发明（Not Invent Here）的 NULL

  避免使用 NULL；即使需要存储一个事实上的“空值”到表中时，也不一定非得使用 NULL。

  也许可以使用 0、某个特殊值，或者空字符串作为代替。

## 范式和反范式

范式化的好处：

1. 范式化的更新操作通常比反范式化要快。
2. 当数据较好的范式化时，就只有很少或者没有重复数据，所以只需要只需要修改更少的数据。
3. 范式化的表通常更小，可以更好的放在内存里，所以执行操作会更快。
4. 很少有多余的数据意味着检索列表数据时很少需要 DISTINCT 或者 GROUP BY 语句。

范式化设计的 schema 的缺点时通常需要关联。也可能让一些索引策略无效。

反范式化的 schema 可以很好的避免关联。如果不需要关联表，则对大部分查询最差的情况——即使表没有使用索引——是全表扫描。当数据比内存大时这可能比关联要快得多，因为这样避免了随机 I/O。

最常用的就是混用范式化和反范式化；部分范式化得 schema、缓存表，以及其他技巧。

最常见得反范式化数据的方法是复制或者缓存，在不同的表中存储相同的特定列。

## 缓存表和汇总表

有时提升性能最好的方法是在同一张表中保存衍生的冗余数据。然而，有时也需要创建一张完全独立的汇总表或缓存表。

1. 缓存表：表示存储那些可以比较简单的从 schema 其他表获取（但每次获取的速度比较慢）数据的表（例如 ，逻辑上冗余的数据）。
2. 汇总表：保存的是使用 GROUP BY 语句聚合数据的表（例如，数据不是逻辑上冗余的）
3. 计数器表：在更新计数器表时可能碰到并发问题。解决这个问题可以将计数器保存在多行中，每次随机选择一行进行更新。

* 更快地读，更慢地写

为了提升读查询的速度，经常会需要建一些额外索引，增加冗余列，甚至是创建缓存表和汇总表。这些方法会增加写查询的负担，也需要额外的维护任务，但在设计高性能数据库时，这些都是常见的技巧:虽然写操作变得更慢了，但更显著地提高了读操作的性能。

然而，写操作变慢并不是读操作变得更快所付出的唯一代价，还可能同时增加了读操作和写操作的开发难度。

## 加快 ALTER TABLE 操作的速度

1. 先在一台不提供服务的机器上执行 ALTER TABLE 操作，然后和提供服务的主库进行切换；
2. “影子拷贝”。这个用要求的表结构创建一张和源表无关的新表，然后通过重命名和删表操作交换两张表。