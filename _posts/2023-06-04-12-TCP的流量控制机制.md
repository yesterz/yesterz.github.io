---
title: TCP的流量控制机制✅
date: 2023-06-04 21:09:00 +0800
author: ltfy
categories: [计算机网络]
tags: [计算机网络]
pin: false
math: false
mermaid: false
---

# 【网络协议 12】TCP的流量控制机制✅

一般来说，我们总是希望数据传输的更快一些，但如果发送方把数据发送的很快，而接收方来不及接收，这就可能造成数据的丢失。流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。

对于成块数据流，TCP 利用滑动窗口机制来实现流量的控制，对于交互数据流，TCP利用捎带ACK和Nagle算法来实现流量的控制。

后两种就不说了，上篇博文中将已经写得比较清楚了，对于滑动窗口机制，上篇博文中也又说到，只是没有刻意提到用滑动窗口来实现流量的控制。下面就详细说下利用滑动窗口机制来实现流量控制的机制，先看下图：

![Untitled](%E3%80%90%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2012%E3%80%91TCP%E7%9A%84%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E6%9C%BA%E5%88%B6%E2%9C%85%202e2a87aec4294e20ab4258f08ca90938/Untitled.png)

我们假设 A 向 B 发送数据。在连接建立时，B 告诉了 A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP 的窗口单位是字节，不是报文段。TCP连接建立时的窗口协商过程在图中没有显示出来。再设每一个报文段为100字节长，而数据报文段序号的初始值设为1。大写 ACK 表示首部中的确认位 ACK，小写 ack 表示确认字段的值。

从图中可以看出，B 进行了三次流量控制。第一次把窗口减少到 rwnd = 300 ，第二次又减到了 rwnd = 100 ，最后减到 rwnd = 0 ，即不允许发送方再发送数据了。这种使发送方暂停发送的状态将持续到主机B重新发出一个新的窗口值为止。

我们考虑一种特殊情况，如果 B 在向 A 发送了零窗口报文段后不久，B的接收缓存又有了一些存储空间，于是 B 向 A 发送了一个 rwnd=400 的报文段，然而这个报文段在传送过程中丢失了，A 就一直等待 B 发送非零窗口的报文通知，而 B 一直等待 A 发送数据，如果没有任何措施的话，这话死锁的局面会一直延续下去。

为了解决这个问题，TCP 为每一个连接设有一个持续计时器(也叫坚持定时器)。只要 TCP 连接的一方收到对方的零窗口通知，就启动持续计时器。若持续计时器设置的时间到期，就发送一个零窗口控测报文段（携1字节的数据），对方在收到探测报文段后，在对该报文段的确认洪给出现在的窗口值，如果窗口值仍未零，则收到这个报文段的一方就重新设置持续计时器，如果窗口不为零，那么死锁的僵局就被打破了。

糊涂窗口综合症。设想一种情况，TCP 接收方的缓存已满，而应用进程一次只从接收缓存中读取1字节（这样就使接收缓存空间仅腾出1字节），然后向发送方发送确认，并把窗口设置为 1 个字节（但发送的数据报为 40 字节长）。接收，发送方又发来1个字节的数据（发送方的IP数据报是41字节）。接收方发回确认，仍然将窗口设置为1个字节。这样，网络的效率很低。要解决这个问题，可让接收方等待一段时间，或者等到接收方缓存已有一半空闲的空间。只要出现这两种情况之一，接收方就发回确认报文，并向发送方通知当前的窗口大小。此外，发送方也不要发送太小的报文段，而是把数据报积累成足够大的报文段，或达到接收方缓存的空间的一半大小时再发送给接收端。