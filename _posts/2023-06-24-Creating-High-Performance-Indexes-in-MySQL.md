---
title: 创建高性能的索引
date: 2023-06-24 14:09:00 +0800
author: 
categories: [Database]
tags: [MySQL, Database]
pin: false
math: false
mermaid: false
img_path: /assets/images/2023-06-24-Creating-High-Performance-Indexes-in-MySQL
---

ch5 创建高性能的索引

索引（在 MySQL 中也叫做“键（key）”）是存储引擎用于快速找到记录的一种数据结构。

## 索引基础

在 MySQL 中，索引是在存储引擎层而不是服务器层实现的。

**索引的用处**

1. 快速查找匹配WHERE子句的行
2. 从consideration中消除行,如果可以在多个索引之间进行选择，mysql通常会使用找到最少行的索引
3. 如果表具有多列索引，则优化器可以使用索引的任何最左前缀来查找行
4. 当有表连接的时候，从其他表检索行数据
5. 查找特定索引列的min或max值
6. 如果排序或分组时在可用索引的最左前缀上完成的，则对表进行排序和分组
7. 在某些情况下，可以优化查询以检索值而无需查询数据行

**索引的分类：**主键索引、唯一索引、普通索引、全文索引、组合索引

- **B-Tree 索引**

![image-20240404175917536](image-20240404175917536.png)

**可以使用 B-Tree 索引的查询类型/匹配方式**

1. 全值匹配：全值匹配指的是和索引中的所有列进行匹配
2. 匹配最左前缀 ：只匹配前面的几列
3. 匹配列前缀：可以匹配某一列的值的开头部分
4. 匹配范围值：可以查找某一个范围的数据
5. 精确匹配某一列并范围匹配另外一列：可以查询第一列的全部和第二列的部分
6. 只访问索引的查询：查询的时候只需要访问索引，不需要访问数据行，本质上就是覆盖索引

- **哈希索引**

基于哈希表的实现，只有精确匹配索引所有列的查询才有效；

在 MySQL 中，只有 memory 的存储引擎显式支持哈希索引；

哈希索引自身只需存储对应的hash值，所以索引的结构十分紧凑，这让哈希索引查找的速度非常快

- **哈希索引的限制**

1. 哈希索引只包含哈希值和行指针，而不存储字段值，索引不能使用索引中的值来避免读取行
2. 哈希索引数据并不是按照索引值顺序存储的，所以无法进行排序
3. 哈希索引不支持部分列匹配查找，哈希索引是使用索引列的全部内容来计算哈希值
4. 哈希索引支持等值比较查询，也不支持任何范围查询
5. 访问哈希索引的数据非常快，除非有很多哈希冲突，当出现哈希冲突的时候，存储引擎必须遍历链表中的所有行指针，逐行进行比较，直到找到所有符合条件的行
6. 哈希冲突比较多的话，维护的代价也会很高

- **组合索引**

当包含多个列作为索引，需要注意的是正确的顺序依赖于该索引的查询，同时需要考虑如何更好的满足排序和分组的需要

建立组合索引 a, b, c

| statement                           | 索引是否发挥作用   |
| ----------------------------------- | ------------------ |
| where a=3                           | 是，只使用了 a     |
| where a=3 and b=5                   | 是，使用了a, b     |
| where a=3 and b=5 and c=4           | 是，使用了 a, b, c |
| where b=3 or where c=4              | 否                 |
| where a=3 and c=4                   | 是，仅使用了 a     |
| where a=3 and b>10 and c=7          | 是，使用了 a,b     |
| where a=3 and b like ‘%xx%’ and c=7 | 使用了 a           |

## 索引的优点

1. 大大减少了服务器需要扫描的数据量；
2. 帮助服务器避免排序和临时表；
3. 将随机 I/O 变成顺序 I/O

## 高性能的索引策略

### 独立的列

“独立的列”是指索引列不能是表达式的一部分，也不能是函数的参数。

```
where actor_id + 1 = 5;
```

上面这个就不能解析，不能用索引，应该将单独的列放在比较符号的一侧。

### 前缀索引和索引选择性

索引选择性（selectivity）是指，不重复的索引值（也称为基数，cardinality）和数据表的记录总数（#T）的比值，范围从 1/#T 到 1 之间。

索引选择性越高则查询效率越高，因为选择性高的索引可以让  MySQL 在查找时过滤掉更多的行。

唯一索引的选择性是 1，这是最好的索引选择性，性能也是最好的。

一般情况某个列前缀的选择性也是足够高的，足以满足查询性能。要选择足够长的前缀索引，又不能太长，足够长以使得前缀索引的选择性接近于索引整个列。就是，前缀的“基数”应该接近于完整列的“基数”。

### 多列索引

常见的错误：为每个列创建独立的索引，或者按照错误的顺序创建多列索引。

### 选择合适的索引顺序

#### 聚簇索引

- 聚簇索引：不是单独的索引类型，而是一种数据存储方式，指的是数据行跟相邻的键值紧凑的存储在一起
- 非聚簇索引：数据文件跟索引文件分开存放

**聚簇索引优点**

1. 可以把相关数据保存在一起
2. 数据访问更快，因为索引和数据保存在同一个树中
3. 使用覆盖索引扫描的查询可以直接使用页节点中的主键值

**聚簇索引缺点**

1. 聚簇数据最大限度地提高了IO密集型应用的性能，如果数据全部在内存，那么聚簇索引就没有什么优势
2. 插入速度严重依赖于插入顺序，按照主键的顺序插入是最快的方式
3. 更新聚簇索引列的代价很高，因为会强制将每个被更新的行移动到新的位置
4. 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临页分裂的问题
5. 聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候

#### 索引覆盖

1. 如果一个索引包含所有需要查询的字段的值，我们称之为覆盖索引
2. 不是所有类型的索引都可以称为覆盖索引，覆盖索引必须要存储索引列的值
3. 不同的存储实现覆盖索引的方式不同，不是所有的引擎都支持覆盖索引，memory不支持覆盖索引

**覆盖索引优势**

1. 索引条目通常远小于数据行大小，如果只需要读取索引，那么mysql就会极大的较少数据访问量
2. 因为索引是按照列值顺序存储的，所以对于IO密集型的范围查询会比随机从磁盘读取每一行数据的IO要少的多
3. 一些存储引擎如MYISAM在内存中只缓存索引，数据则依赖于操作系统来缓存，因此要访问数据需要一次系统调用，这可能会导致严重的性能问题
4. 由于INNODB的聚簇索引，覆盖索引对INNODB表特别有用

### 使用索引扫描来做排序

MySQL 有两种方式可以生成有序结果：通过排序操作；或者按索引顺序扫描

如果 EXPLAIN 出来的 type 列的值为“index”，则说明 MySQL 使用了索引扫描来做排序（并不是 Extra 列的 Using index）

### 压缩（前缀压缩）索引

默认压缩字符串

### 冗余和重复索引

冗余：在相同列上创建多个索引，影响性能

重复索引：在相同的列上按照相同的顺序创建的相同类型的索引。**应该避免创建重复索引。**

### 未使用的索引

这种用不到的，建议直接删除

### 索引和锁

索引可以让查询锁定更少的行。